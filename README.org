* Obsidian
  
  An embedded language for GPU kernel programming. 
  
* Current features 
    + Pull arrays: traditional "arrays as function from index to value" 
    + Push arrays: a computation that is parameterised on a "write function". 
    + Mutable arrays:
      Mutable arrays in shared memory can be created.
      Global mutable arrays can be passed into a kernel as an argument. 
    + Atomic operations on mutable arrays.
    + Executing kernels from within Haskell is possible on platforms 
      supported by the CUDA bindings (Linux, Mac). 
      Obsidian.Run.CUDA.Exec provides a very low level interface to running kernels. 
    + A collection of sequential building blocks for sequential (reg->reg 
       computations). 
          + Fold 
          + Scan 
          + Sort (todo). How ? Which kind of sort. I want one with known number of iterations and in-place capability. 
          + Merge (todo) 
          + Filter (todo, Tricky, whats the lengths?) 
  
* Latest tweaks 
  + pMap is now just fmap! (simplification)
  

* TODOs
  + Look at code generation, is there a problem with the memory management ? 
  + global arrays have sizes! make the code generation aware of this! 
  + Think about completely dissallowing Int and Word as types in Obsidian programs.
    Require that the programmer explicitly makes a Int32, Int64, Word32, Word64 Choice-
  + (In Progress) update the SPDMC based code outputer (cleaner, nicer) 
  + clean up and check for bugs in: 
    * CodeGen.Memory.hs
    * CodeGen.Liveness.hs 
  + The CSE code is definitely completely broken in relation 
    to all news now.
  + More thinking about the mutable array interface(and implementation) is needed.
  + Generating a kernel should not really need the prototypical input arrays. 
    The sizes of Local computations are now set by the splitUp functions. 
    The number and types of input a generated kernel takes should be possible 
    to extract from the type of the obsidian function used to generate it. 
  
	    
